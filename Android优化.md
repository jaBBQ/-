# Android优化

## App性能概览和与平台化实践

#### App性能优化难题：

+ 性能表现差
  1. App启动慢、卡顿、丢帧
  2. 内存占用率高、抖动频繁
  3. 耗电、网络请求慢
  4. 崩溃率、异常率高
+ 线上问题无从追查
  1. 如何保证异常感知灵敏度
  2. 如何复原“案发现场”
  3. 如何快速止血成功
+ 性能优化的长期开销很大
  1. 如何扼杀问题于萌芽
  2. 优化效果如何长期保持
+ 总结
  1. 性能表现好
  2. 线上问题容易追查
  3. 长期投入小

#### App性能优化解决方案演进

#### 项目初期

+ 只关心崩溃率、不采集性能数据
+ 没有性能检测、优化方案
+ 没有排查问题手段

#### 项目壮大期

+ 指标采集、不够全以及深入
+ 接入成熟APM、排查手段单一
+ 线下检测、优化、方案不成型

#### 项目成熟期

+ 关注性能问题、数据丰富、手段多样化
+ 线上、线下一套完善解决方案
  1. 误区：对线上不重视
  2. 侧重点：线下预防、线上监控
  3. 方案不同：线下可用黑科技
+ 自建APM，新产品可以快速接入
  1. 成熟APM通用，但不满足个性化需求
  2. 外部APM与内部系统难打通，带来的时间成本
  3. 数据必须掌握在自己手中

####  业界优秀的平台化实践

Crash收集平台：

+ Bugly平台
  1. 数据采集、上报成功率高
  2. 包含Java、Native崩溃

APM平台：

+ 听云
  1. 通用的性能解决方案，数据采集完善
  2. 方便接入，但不满足个性化需求，数据隐患

自建解决方案：

美团、携程、360

1. 贴合自身业务特点，满足定制化需求
2. 数据安全

#### QA：

1. 为什么做性能优化
   + 体验差影响核心指标
   + 线上问题追查困难
   + 降低性能优化的长期开销
2. 介绍一下你们的性能优化平台
   + 交代背景
   + 具体讲解
3. 为什么要自建APM
   + 需求层面
   + 效率层面
   + 数据安全

## APP启动优化介绍

#### 背景介绍

+ 第一体验
+ 八秒定律

#### 启动分类

+ 冷启动：耗时最多，衡量标准
+ 热启动：最快
+ 温启动：较快

#### 相关任务

冷启动之前：

+ 启动APP
+ 加载空白Window
+ 创建进程

随后任务：

+ 创建Application
+ 启动主线程
+ 创建MainActivity

+ 加载布局
+ 布置屏幕
+ 首帧绘制

#### 优化方向

Application和Activity生命周期

## 启动时间的测量方式

#### adb 命令

```
adb shell am start -W packagename/首屏Activity
```

1. ThisTime： 最后一个Activity启动耗时
2. TotalTime：所有Acitivity启动耗时
3. WaitTime：AMS启动Activity的总耗时

问题：

+ 线下使用方便
+ 非严谨，精确时间

#### 手动打点

启动时埋点。启动结束时埋点，二者差值

误区：onWindowFocusChanged只是首帧时间

正解：真实数据展示，Feed第一条展示

+ 精确，可以带到线上，推荐使用
+ 避开误区，采用Feed第一条展示
+ addOnDrawListener要求API 16

## 启动优化工具选择

+ 两方式相互补充
+ 正确认识工具以及不同场景合适的工具

#### traceView

+ 图形的形式展示执行时间、调用栈等
+ 信息全面，包含所有线程

问题：

+ 运行时开销严重，整体都会变慢

+ 可能会带偏优化方向
+ traceview和cpu profile

#### systrace

+ 结合Android内核的数据，生产html报告
+ API 18 以上使用，推荐TraceCompat
+ 轻量级，开销小
+ 直观反映CPU利用率
+ CPUtime和WallTime区别
  + WallTime是代码执行时间
  + CPUtime是代码消耗CPU的时间（重点指标）

## 优雅获取方法耗时

+ 常规方式
+ AOP介绍
+ AOP实战

### 常规方式

背景：需要知道启动阶段所有方法的耗时

实现：手动埋点

问题：

+ 侵入性强
+ 工作量大

### AOP介绍

+ 针对同一类问题的统一处理
+ 无侵入添加代码
+ 无侵入性
+ 修改方便

#### AspectJ使用

Join Point：

程序运行时的执行点，可以作为切面的地方

+ 函数调用、执行
+ 获取、设置变量
+ 类初始化

**PointCut**

带条件的JoinPoints

**Advice**

一种Hook，要插入代码的位置

+ Before：PointCut之前执行
+ After：PointCut之后执行
+ Around：Point之前、之后分别执行

**语法简介**

Before：Advice，具体插入位置

execution：处理Join Point类型，call，execution

## 异步优化

+ 优化技巧
+ 异步优化

#### 优化技巧

Theme切换：感觉上的快

#### 异步优化

核心思想：子线程分担主线程任务，并行减少时间

注意：

+ 不符合异步要求
+ 需要在某阶段完成
+ 区分CPU密集型、IO密集型任务

## 异步初始化的最优解-启动器

+ 常规异步痛点
  + 代码不够优雅
  + 场景不好处理（依赖关系）
  + 维护成本高
+ 启动器介绍
+ 启动器实战

启动器介绍

核心思想：充分利用CPU多核，自动梳理任务顺序

启动器流程

1. 代码Task化，启动逻辑抽象为Task
2. 根据所有任务依赖关系排序生成一个有向无环图
3. 多线程按照排序后的优先级依次执行

## 更优秀的延迟初始化方案

+ 常规方案
+ 更优方案

### 常规方案

背景：某些任务在特定时机后初始化

1. 

```kotin
New handle().postDelayed
```

2. Feed展示之后

常规初始化痛点：

1. 时机不便控制
2. 导致Feed卡顿

### 更优方案

核心思想：对延迟任务进行分批初始化，利用IdleHandler特性，空闲执行

+ 执行时机明确
+ 缓解Feed卡顿

## 启动优化其他方案

+ 优化总方针
+ 注意事项
+ 其他方案

### 优化总方针

+ 异步、延迟、懒加载
+ 技术、业务相结合

### 注意事项

+ Wall Time 与 Cpu Time
  + Cpu  Time才是优化方向
  + 按照Systrace及Cpu Time跑满Cpu
+ 监控的完善
  + 线上监控多阶段时间（App、Activity、 生命周期间隔时间）
  + 处理聚合看趋势
+ 收敛启动代码修改权限
  + 结合CI修改启动代码需要Review或通知

### 其他方案

+ 提前加载SP
  + Multidex之前加载， 利用此阶段的CPU
  + 覆写getApplicationContext()返回this
+ 启动阶段不启动子进程
  + 子进程会共享CPU资源，导致主进程CPU紧张
  + 注意启动顺序：App onCreate 之前是ContentProvider
+ 类加载优化：提前异步类加载
  + Class.forName()只加载类本身以及其静态变量的引用类
  + new 类实例，可以额外加载类成员变量的引用类
+ 启动阶段抑制GC
+ CPU锁频（可能会导致耗电量增加）

## 启动优化方案总结

+ 获取方法耗时
+ 异步、延迟初始化
+ 其他方案

获取方法耗时

+ 常规方法
+ AOP
+ Wall Time 和 Cpu Time区别

异步初始化

+ 常规异步
+ 启动器
+ 注意痛点以及启动器优势的理解

延迟初始化

+ 常规方法
+ 结合IdleHandler

其他优化

+ 提前加载SP
  + Multidex之前加载， 利用此阶段的CPU
  + 覆写getApplicationContext()返回this
+ 启动阶段不启动子进程
  + 子进程会共享CPU资源，导致主进程CPU紧张
  + 注意启动顺序：App onCreate 之前是ContentProvider
+ 类加载优化：提前异步类加载
  + Class.forName()只加载类本身以及其静态变量的引用类
  + new 类实例，可以额外加载类成员变量的引用类
+ 启动阶段抑制GC
+ CPU锁频（可能会导致耗电量增加）

## App内存优化

+ 内存优化介绍
+ 优化工具选择

背景介绍

+ 内存是大问题但缺乏关注
+ 压死骆驼的最后一根稻草

内存问题

+ 内存抖动：锯齿状、GC导致卡顿
+ 内存泄漏：可用内存较少、频繁GC
+ 内存溢出：OOM、程序异常

### 工具选择

#### Memory Profile

特点：

+ 实时图标表展示应用内存使用量
+ 识别内存泄露、抖动等
+ 提供捕获堆转储、强制GC以及跟踪内存分配的能力

总结:

+ 方便直观
+ 线下平时使用

#### Memory Analyzer

+ 强大的Java Heap分析工具，查找内存泄漏及内存占用
+ 生成整体报告、分析问题等
+ 线下深入使用

#### LeakCanary

+ 自动内存泄漏检测
+ 线下集成

### Android内存管理机制

+ Java内存管理机制
+ Android内存管理机制

#### Java内存回收算法

+ 标记-清楚算法

  + 标记出所有需要回收的对象
  + 统一回收所有被标记的对象

  问题：

  + 标记和清楚的效率不高
  + 产生大量不连续的内存碎片

+ 复制算法

  + 将内存划分为大小相等的两块
  + 一块内存用完之后复制存活对象到另一块
  + 清理另一块内存

  问题：

  + 实现简单，运行高效
  + 浪费一半空间，代价大

+ 标记- 整理算法

  + 标记过程与“标记-清楚”算法一样
  + 存活对象往一端进行移动
  + 清理其余内存

  问题:

  + 避免标记-清理导致的内存碎片
  + 避免复制算法的空间浪费

+ 分代收集算法

  + 结合多种收集算法优势
  + 新生代对象存活率低，复制
  + 老年代对象存活率高，标记-整理

#### Android内存管理机制

+ 内存弹性分配，分配值与最大值受具体设备影响
+ OOM场景：内存真正不足、可用内存不足

#### Dalvik和Art区别

+ Dalvik仅固定一种回收算法
+ Art回收算法可运行期选择
+ Art具备内存整理能力，减少内存空洞

#### Low Memory Killer

+ 进程分类
+ 回收收益

### 内存抖动解决实战

+ 内存抖动介绍
+ 内存抖动解决实战
+ 总结

内存抖动介绍

定义：内存频繁分配和回收导致内存不稳定

表现：频繁GC、内存曲线呈锯齿状

危害：导致卡顿、OOM

内存抖动导致OOM

+ 频繁的创建对象，导致内存不足和内存碎片
+ 不连续的内存片无法被分配，导致OOM

内存抖动解决实战

+ 使用Memory Profile初步排查
+ 使用Memory Profile或CPU Profile结合代码排查

内存抖动解决技巧

+ 找循环或者频繁调用的地方

### 内存泄漏解决实战

+ 内存泄漏介绍
+ 内存泄漏解决实战
+ 总结

内存泄漏介绍

定义：内存中存在已经没有用的对象

表现：内存抖动，可用内存逐渐减少

危害：内存不足、GC频繁、OOM

Memory Analyzer

### ARTHook检测不合理图片

+ Bitmap内存模型
+ 常规方式
+ ARTHook实战

#### Bitmap内存模型

+ API 10 之前Bitmap自身在Dalvik Heap中，像素在Native
+ API 10 之后像素也被放在Dalvik Heap中
+ API 26 之后像素在Native

##### 	获取Bitmap占用内存

+ getByteCount
+ 宽 * 高 * 单个像素大小

#### 常规方式

背景：图片对内存优化至关重要，图片宽高大于控件宽高

实现：继承ImageView，覆写实现计算大小

缺点：

+ 侵入性强
+ 不通用

#### ARTHook介绍

挂钩,将额外的代码钩住原有的方法，修改执行逻辑

+ 运行时插桩
+ 性能分析

优点：

+ 无侵入性
+ 通用性强

缺点：

+ 兼容问题大，开源方案不能带的线上环境

### 线上内存监控方案

+ 常规方案
+ LeakCanary定制
+ 线上监控完整方案

常规实现

常规实现：

+ 设定场景线上Dump
  + Dump文件太大，和对象数成正相关，可裁剪
  + 上传失败率高，分析困难
  + 配合一定策略，有一定效果
+ LeakCanary带到线上
  + 预设泄漏怀疑点
  + 发现泄漏回传
  + 不适合所有情况，必须预设怀疑点
  + 分析比较耗时、也容易OOM

#### LeakCanary原理

+ 监控生命周期，onDestory添加RefWatcher检测
+ 二次确定断定发生内存泄漏
+ 分析泄漏，找到引用链
+ 监控组件 + 分析组件

#### LeakCanary定制

+ 预设怀疑点 -> 自动找怀疑点
+ 分析泄漏链路慢 -> 分析Retain size大的对象
+ 分析OOM -> 对象裁剪，不全部加载到内存

#### 线上监控完整方案

+ 待机内存、重点模块内存、OOM率
+ 整体及重点模块GC次数、GC时间
+ 增强的LeakCanary自动化泄漏分析

### 内存优化技巧总结

+ 优化大方向
+ 优化细节
+ 总结

优化大方向

1. 内存泄漏
2. 内存抖动
3. Bitmap

优化细节

1. LargeHeap属性 ： 申请更多内存
2. onTrimMemory：低内存回调
3. 使用优化过的集合：SparseArray
4. 谨慎使用SP
5. 谨慎使用外部库
6. 业务架构设计合理

## Android布局优化

### Android绘制原理及工具选择

绘制原理

+ CPU负责计算显示内容
+ GPU负责栅格化（UI元素绘制到屏幕上）
+ 16ms发出VSync信号触发UI渲染
+ 大多数的Android设备屏幕刷新频率：60Hz

优化工具

+ systrace
  + 关注Frames
  + 正常：绿色原点，丢帧：黄色或红色
  + Alerts栏
+ Layout Inspecter
  + Android Studio自带工具
  + 查看视图层次结构
+ Choreographer
  + 获取FPS，线上使用，具体实时性

Android布局加载原理

